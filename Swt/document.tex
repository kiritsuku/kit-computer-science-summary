\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{mathabx}
\usepackage[margin=2cm]{geometry} % margins
\usepackage{fancyhdr} % site layout

\begin{document}

\section{Planung}
\section{Definition}
\section{Entwurf (Design)}

\subsection{Entwurfsmuster}

\begin{itemize}
  \item Entkopplungsmuster
  \begin{itemize}
    \item Definition
    \begin{itemize}
      \item Ein System wird in Teilkomponenten aufgeteilt, die unabhängig voneinander verwendet und modifiziert werden können.
      \item Kommunikation zwischen Teilkomponenten kann über spezielle Schnittstellen, den Kopplungsgliedern, erfolgen.
    \end{itemize}
    \item Beispiele
    \begin{itemize}
      \item \textit{Adapter (adapter)}: Lässt inkompatible Schnittstellen miteinander zusammenarbeiten
      \item \textit{Beobachter (observer)}: Änderung eines Zustandes führt zu einer Benachrichtigung und Aktualisierung aller abhängigen Komponenten. 
      \item \textit{Brücke (bridge)}: Entkoppelt eine Abstraktion von ihrer Implementierung, damit beide unabhängig voneinander variiert werden können.
      \item \textit{Iterator (iterator)}: Ermöglicht den sequentiellen Zugriff auf die Elementen eines Containers ohne dabei die interne Repräsentation der Elemente offenlegen zu müssen.
      \item \textit{Stellvertreter (proxy)}: Kontrolliert den Zugriff auf ein Objekt durch eine vorgelagerte Schnittstelle.
      \item \textit{Dekorierer (decorator)}: Kann Funktionalität dynamisch zu einem Objekt hinzufügen
      \item \textit{Vermittler (mediator)}: Kapselt mehrere Objekte um sie gemeinsam zu verwalten und um zu verhindern, dass die Objekte sich gegenseitig referenzieren.
    \end{itemize}
  \end{itemize}
  \item Variantenmuster
  \begin{itemize}
    \item Definition
    \begin{itemize}
      \item Gemeinsamkeiten von verwandten Einheiten werden extrahiert und an einer einzigen Stelle beschrieben
      \item Einheitliche Verwendung von Komponenten
      \item Vermeidung von Codeduplikaten
    \end{itemize}
    \item Beispiele
    \begin{itemize}
      \item \textit{Abstrakte Fabrik (abstract factory)}: Erzeugt Familien von Objekten, die wiederrum die konkreten Implementierungen erzeugen.
      \item \textit{Besucher (visitor)}: Trennt Verhaltensweisen von dem dazugehörigen Objekt 
      \item \textit{Erbauer}
      \item \textit{Fabrikmethode (factory method)}: Ermöglicht die Erzeugung verschiedenen konkreter Implementierungen indem die Erzeugung gekapselt über eine gemeinsame Schnittstelle erfolgt. 
      \item \textit{Kompositum (composite)}: Ermöglicht es Gruppen von Objekten als einzelne Objekte zu betrachten, indem sie zusammengefasst und über eine einzelne Schnittstelle gemeinsam angesprochen werden können.
      \item \textit{Schablonenmethode (template method)}: Definiert das Skelett eines Algorithmus in einer Operation und delegiert einzelne Schritte an Unterklassen
      \item \textit{Strategie (strategy)}: Definiert eine Schnittstelle, die den Zugriff auf verschiedene Implementierungen erlauben und sie somit zur Laufzeit austauschbar machen.
    \end{itemize}
  \end{itemize}
  \item Zustandshandhabungs-Muster
  \begin{itemize}
    \item Definition
    \begin{itemize}
      \item Zustände von Objekten werden behandelt
    \end{itemize}
    \item Beispiele
    \begin{itemize}
      \item \textit{Einzelstück (singleton)}: Bewirkt, dass eine Klasse genau ein mal instanziiert werden kann.
      \item \textit{Fliegengewicht (flyweight)}: Dient als Cache um zu verhindern, dass oft benutzte Objekte immer wieder neu erzeugt werden müssen.
      \item \textit{Memento (memento)}: Ermöglicht es den Zustand eines Objekts zu sichern um jederzeit wieder darauf zugreifen zu könnnen.
      \item \textit{Prototyp (prototype)}: Stellt einen unveränderlichen Ausgangszustand bereit, der nur modifiziert werden kann nachdem er kopiert wurde.
      \item \textit{Zustand (state)}: Inbegriff eines Automaten - Das Verhalten eines Objekts hängt von dessen Zustand ab.
    \end{itemize}
  \end{itemize}
  \item Steuerungs-Muster
  \begin{itemize}
    \item Definition
    \begin{itemize}
      \item Kontrollfluss wird kontrolliert, indem zur richtigen Zeit die richtigen Methoden aufgerufen werden.
    \end{itemize}
    \item Beispiele
    \begin{itemize}
      \item \textit{Befehl (command)}: Operation wird als Objekt definiert - Definition eines Lambdas.
      \item \textit{Auftraggeber/-nehmer (master/worker)}: Zu verrichtende Aufgaben werden von einem Master auf die Worker aufgeteilt. Ermöglicht fehlertolerante und parallele Berechnungen - Definition von Aktoren.
    \end{itemize}
  \end{itemize}
  \item Virtuelle Maschinen
  \begin{itemize}
    \item Definition
    \begin{itemize}
      \item Simulation eines Systems, das ein Programm mit bestimmten Eingabedaten arbeiten lässt. 
    \end{itemize}
    \item Beispiele
    \begin{itemize}
      \item \textit{Interpretierer (interpreter)}: Spezifiziert die Auswertung von Expressions und Statements.
    \end{itemize}
  \end{itemize}
  \item Bequemlichkeitsmuster
  \begin{itemize}
    \item Definition
    \begin{itemize}
      \item Dienen dem Ersparnis von Schreib- und Denkarbeit.
    \end{itemize}
    \item Beispiele
    \begin{itemize}
      \item \textit{Bequemlichkeits-Klasse (convenience class)}: Klasse, die nur zur Datenhaltung dient bzw. Bequemlichkeits-Methoden bereitstellt.
      \item \textit{Bequemlichkeits-Methode (conveniece method)}: Default-Parameter für Methoden.
      \item \textit{Fassade (facade)}: Bietet eine einheitliche Schnittstelle, für eine Menge weiterer Schnittstellen.
      \item \textit{Null-Objekt (null object)}: Meist als Singleton implementiertes Objekt, das eine Implementierung einer Schnittstelle anbietet, die nichts tut.
    \end{itemize}
  \end{itemize}
\end{itemize}

\section{Implementierung}

\section{Testen und Prüfen}
\begin{itemize}
  \item Testverfahren
  \begin{itemize}
    \item Testende Verfahren $\to$ Fehler erkennen
    \item Verifizierende Verfahren $\to$ Korrektheit beweisen
    \item Analysierende Verfahren $\to$ Eigenschaften einer Systemkomponente bestimmen
  \end{itemize}
  \item Fehlerarten
  \begin{itemize}
    \item \textit{Versagen/Ausfall (failure, fault)}: Ein Ereignis - Software weicht im Verhalten von der Spezifikation ab.
    \item \textit{Defekt (bug)}: Ein Zustand - ein Mangel in einem Softwareprodukt.
    \item \textit{Irrtum/Herstellungsfehler (mistake)}: Ein Vorgang - menschliche Aktion, die einen Defekt verursacht.
  \end{itemize}
  \item Testhelfer
  \begin{itemize}
    \item \textit{Stummel (stub)}: Platzhalter für noch nicht umgesetzte Funktionalität
    \item \textit{Attrappe (dummy)}: Simulation der Implementierung
    \item \textit{Nachahmung (mock)}: Dummy mit zusätzlicher Funktionalität, wie z.B. Vorgabe von Verhaltensweisen
  \end{itemize}
  \item Fehlerklassen
  \begin{itemize}
    \item Anforderungsfehler (Defekt im Pflichtenheft)
    \begin{itemize}
      \item Inkorrekte Angaben von Benutzerwünschen
      \item Unvollständige Angaben über funktionale Anforderungen etc.
      \item Inkonsistenz verschiedener Anforderungen
      \item Undurchführbarkeit
    \end{itemize}
    \item Entwurfsfehler (Defekt in der Spezifikation)
    \begin{itemize}
      \item Unvollständige oder fehlerhafte Umsetzung der Anforderung
      \item Inkonsistenz der Spezifikation oder des Entwurfs
      \item Inkonsistenz zwischen Anforderung, Spezifikation und Entwurf
    \end{itemize}
    \item Implementierungsfehler (Defekt im Programm)
    \begin{itemize}
      \item Fehlerhafte Umsetzung der Spezifikation in ein Programm
    \end{itemize}
  \end{itemize}
  \item Begriffe
  \begin{itemize}
    \item \textit{Softwaretest}: Führt eine Softwarekomponente aus und überprüft deren Verhalten
    \item \textit{Testobjekt/Testling/Prüfling}: Die zu überprüfende Softwarekomponente
    \item \textit{Testfall}: Datensatz, der zur Ausführung eines Testlings benötigt wird
    \item \textit{Testtreiber/Testrahmen}: Versorgt Testlinge mit Testfällen und stößt deren Ausführung an
  \end{itemize}
  \item Testphasen
  \begin{itemize}
    \item \textit{Komponententest (unit test)}: Überprüfung von Einzelmodulen
    \item \textit{Integrationstest (integration test)}: Überprüfung der Zusammenarbeit von Einzelmodulen 
    \item \textit{Systemtest (system test)}: Abschließende Tests beim Entwickler in realer bzw. realistischer Umgebung (ohne Kunde)
    \item \textit{Abnahmetest (acceptance test)}: Test in realer Umgebung in Zusammenarbeit mit dem Kunden
  \end{itemize}
  \item Klassifikation testender Verfahren
  \begin{itemize}
    \item Dynamische Verfahren
    \begin{itemize}
      \item Software wird mit Testfällen versehen und ausgeführt.
      \begin{itemize}
        \item \textit{White Box Testen}: Bestimmen der Werte mit Kenntnis von Kontroll- und/oder Datenfluss
        \item \textit{Black Box Testen}: Bestimmen der Werte ohne Kenntnis von Kontroll- und/oder Datenfluss aus der Spezifikation heraus
      \end{itemize}
      \item Testen in realer (realistischer) Umgebung
      \item Stichprobenverfahren, d.h. die Korrektheit der Software wird nicht bewiesen
    \end{itemize}
    \item Statische Verfahren
    \begin{itemize}
      \item Analyse des Quellcodes
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Kontrollflussorientierte (KFO) Testverfahren}
\begin{itemize}
  \item Zwischensprache
  \item Strukturerhaltende Transformation
  \item Grundblock (GB) (basic block)
  \begin{itemize}
    \item Fortlaufende Folge von Anweisungen der Zwischensprache
    \item Eintritt nur am Anfang
    \item Austritt nur am Ende
  \end{itemize}
  \item Kontrollflussgraph (KFG) (conrtol flow graph)
  \begin{itemize}
    \item Gerichteter Grah $G$ eines Programms $P$ mit $G=(N,E,n_{\text{start}},n_{\text{stopp}})$ wobei
    \begin{itemize}
      \item \textit{$N$}: Menge der GB in $P$
      \item \textit{$E\subseteq N\times N$}: Menge der Kanten, die die Ausführungsreihenfolge von zwei GB angeben
      \item \textit{$n_{\text{start}}$}: Startblock
      \item \textit{$n_{\text{stopp}}$}: Stoppblock
    \end{itemize}
  \end{itemize}
  \item Zweig (branch), vollständige Pfade
  \begin{itemize}
    \item Eine Kante $e\in E$ in einem KFG $G$ wird Zweig genannt
    \item Pfade, die mit $n_{\text{start}}$ anfangen und bei $n_{\text{stopp}}$ aufhören heißen vollständige Pfade
  \end{itemize}
  \item Anweisungsüberdeckung (statement coverage)
  \begin{itemize}
    \item Teststrategie, als $C_{\text{Anweisung}}$ oder $C_0$ bezeichnet, die die Ausführung aller GB in $P$ verlangt
    \[
    C_{\text{Anweisung}}=\frac{\text{Anzahl durchlaufener Anweisungen}}{\text{Anzahl aller Anweisungen}}
    \]
    \item Nicht ausführbare Programmteile können gefunden werden
    \item Nur angebracht wenn keine Schleifen oder Bedingungen ausgeführt werden, ansonsten nicht ausreichend
  \end{itemize}
  \item Zweigüberdeckung (branch coverage)
  \begin{itemize}
    \item Teststrategie, als $C_{\text{Zweig}}$ oder $C_1$ bezeichnet, die das Traversieren aller Zweige im KFG in $G$ verlangt.
    \[
    C_{\text{Zweig}}=\frac{\text{Anzahl traversierter Zweige}}{\text{Anzahl aller Zweige}}
    \]
    \item Nicht ausgeführte Zweige können entdeckt werden
    \item Berücksichtigt weder Pfade noch komplexe Bedingungen
    \item Nicht ausreichend zum Testen von Schleifen
    \item Fehlende Zweige nicht testbar
    \item Angebracht wenn keine keine Schleifen und nur atomare Bedingungen vorhanden sind
  \end{itemize}
  \item Pfadüberdeckung (path coverage)
  \begin{itemize}
    \item Teststrategie, als $C_2$ bezeichnet, fordert die Ausführung aller unterschiedlichen Pfade im Programm
    \item Pfadanzahl wächst bei Schleifen sehr stark
    \item Manche Pfade können nicht ausführbar sein, durch sich gegenseitig ausschließende Bedingungen
    \item Mächtigste KFO Teststrategie, aber nicht praktikabel, da schon für kleine Programme zu aufwendig
  \end{itemize}
  \item Bedingungsüberdeckung (BÜ) (condition coverage)
  \begin{itemize}
    \item Zweigüberdeckung nicht immer ausreichend (z.B. bei hierarchischen Bedingungen).
    \item Einfache BÜ
    \begin{itemize}
      \item Jede atomare Bedingung muss einmal mit True und einmal mit False belegt werden
      \item Enthält weder Zweig- noch Anweisungsüberdeckung
      \item Daher: Nicht ausreichendes Testkriterium, noch schwächer als Anweisungsüberdeckung
    \end{itemize}
    \item Mehrfache BÜ
    \begin{itemize}
      \item Jede atomare Bedingung muss mit allen möglichen Kombinationen von True und False belegt werden
      \item $2^n$ Kombinationen bei $n$ Bedingungen
      \item Enthält Zweig- und Anweisungsüberdeckung, aber sehr aufwendig
    \end{itemize}
    \item Minimal-mehrfach BÜ
    \begin{itemize}
      \item Jede atomare oder zusammengesetzte Bedingung muss zu True oder False evaluieren
      \item Enthält Zweigüberdeckung, daher sinnvolle Ergänzung
    \end{itemize}
  \end{itemize}
  \item Subsumieren
  \begin{itemize}
    \item Ein Testverfahren für Kriterium $a$ subsumiert ein Testverfahren für Kriterium $b$, wenn alle Pfade, die $a$ erfüllen, auch $b$ erfüllen
    \item Hierarchie der KFO-Teststrategien ($\implies$: subsumiert)
    \begin{itemize}
      \item Pfadüberdeckung $\implies$ Zweigüberdeckung $\implies$ Anweisungsüberdeckung
      \item Mehrfache BÜ $\implies$ Minimal-mehrfach BÜ $\implies$ Einfache BÜ
      \item Minimal-mehrfach BÜ $\implies$ Zweigüberdeckung
    \end{itemize}
  \end{itemize}
  \item Kurzauswertung
  \begin{itemize}
    \item Die Auswertung einer zusammengesetzten Bedingung wird abgebrochen, sobald das Ergebnis feststeht
    \item Bsp: \texttt{a != 0 \&\& x/a > 1} $\implies$ Auswertung wird abgebrochen wenn $a=0$
    \item Erfordert mehr Testen, da weiter rechts stehende Ausdrücke von den weiter links stehenden abhängig sind.
    \item Seiteneffekte der aufgerufenen Ausdrücke beachten
  \end{itemize}
\end{itemize}

\subsection{Funktionale Tests}
\begin{itemize}
  \item Ziel: Testen der spezifizierten Funktionalität
  \item Testfälle aus der Spezifikation ableiten
  \item Vorteil: Testfälle unabhängig von der Implementierung erstellbar
  \item Nachteil: mögl. kritische Pfade nicht bekannt und nicht getestet
  \item Funktionale Äquivalenzklassenbildung
  \begin{itemize}
    \item Zerlegung des Wertebereichs der Eingabeparameter einer Funktion und den Definitionsbereich der Ausgabeparameter in Äquivalenzklassen (ÄK)
    \item Ziel ist es, die Annahme über die Verarbeitung eines Wertes einer ÄK machen zu können, dass sich alle Werte  
  \end{itemize}
  \item Grenzwertanalyse
  \begin{itemize}
    \item 
  \end{itemize}
  \item Zufallstests
  \begin{itemize}
    \item 
  \end{itemize}
  \item Test von Zustandsautomaten
  \begin{itemize}
    \item 
  \end{itemize}
\end{itemize}

\section{Abnahme, Einsatz und Wartung}

\end{document}
